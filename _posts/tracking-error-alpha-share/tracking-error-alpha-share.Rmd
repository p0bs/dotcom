---
title: "Imputing tracking error from active share and the number of stocks"
author: Robin Penfold
date: 2018-08-09
categories:
  - papers
  - performance
draft: false
slug: tracking-error-alpha-share
preview: tracking-error2.jpg
bibliography: Sapra.bib
description: |
  Some  done.
output:
  distill::distill_article:
    self_contained: false
    highlight: pygments
---

```{r te_as1, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

Let's start with some theory.

## Theory

As Steve Sapra at PIMCO shows [@Sapra2013], tracking error can be [linearly expressed in terms of active share](https://www.pimco.com/handlers/displaydocument.ashx?wd=Insight&id=kLIu9UcvyCBS0jJi%2FtvfE6c42hmW3lVquUL%2BwlvMmA1cD3ZUm1TnAaimao8XiqRxMHxIjtzgBFeAxRNXj4V66kGdphANYIBQz%2BrPLKzZlbczeUStlG4GmdN%2FQgcrm%2BD4kjajjI69sE6jgv2N%2BTkx5KBQJGRAK2%2B7Du9I9vTFkZPmP2lcIyv9oxo3V5FgpgLIfABCZ95dphDY4cLvlEAvHYITlFHQGKNUgXjDuD6pcnt77nAHRTmOY8OMJqhcO4Ve5zp38XHjEQ%2F%2BiKCWTmuYNZGRgYVx821tY38NIYBU9u8J%2F209iGotWYBjx3gnozjatWzKbYRN5F2e4EO1UztUaA%3D%3D). (To do so, we must assume that the active product in question has a beta of one and is unconstrained.)

After a little manipulation, it can be shown that:

\(S = \omega / (\bar{\sigma _{e}} \sqrt{2\pi / n})\)    , where:

  * \(S\) -- the expected active share of the product
  
  * \(\omega\) -- the expected tracking error of the product
  
  * \(\bar{\sigma _{e}}\) -- the average idiosyncratic risk of all stocks in the investible universe
  
  * \(n\) -- the number of active stocks in the product

  
Put another way:

\(\omega / S = \bar{\sigma _{e}} \sqrt{2\pi / n} = \bar{\sigma _{e}} \sqrt{2\pi}(1 / \sqrt{n})\)

In other words, if I were to regress \(\omega / S\) against \(1 / \sqrt{n}\) for all the products in a mandate, the resulting beta coefficient would be the empirical estimate of \(\bar{\sigma _{e}} \sqrt{2\pi}\) -- which I could divide by \(\sqrt{2\pi}\) to obtain the emprical estimate of \(\bar{\sigma _{e}}\) for the mandate.


## Calibration

In the rest of this post, I test whether Sapra's way of imputing tracking error from active share works zero.

```{r te_as2, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, layout="l-body-outset"}
suppressMessages(library(tidyverse))
library(readxl)
library(broom)
library(ggiraph)
library(DT)
  
ignore_number <- 12L
  
import <- read_xlsx(
  path = "Active Share info from eVestment.xlsx", sheet = "Mapping", na = "---")
  
tidy_data <- import %>% 
  select(
    ID = ProductId, 
    product_name = `Product Name`, 
    cap_size = `New Cap`, 
    region = `Product: Geographic Region`, 
    active_share = `Average Active share`, 
    tracking_error = `Tracking error - 5yr trailing`, 
    number_holdings = `Current holdings`
    ) %>% 
  mutate(
    number_holdings = as.integer(
      floor(
        as.numeric(number_holdings)
        )
      ),
    ID = as.integer(ID),
    TE_vs_AS = tracking_error/active_share, 
    one_vs_sqrt_n = 1/sqrt(number_holdings),
    region_cap = paste0(region, "-", cap_size),
    region = as.factor(region),
    cap_size = as.factor(cap_size)
    ) %>% 
  filter(
    !is.na(active_share),
    !is.na(tracking_error),
    !is.na(number_holdings),
    active_share != 0,
    tracking_error != 0,
    number_holdings != 0
  )
  
region_cap_data <- tidy_data %>% 
  group_by(region_cap) %>% 
  summarise(number_instances = n()) %>% 
  filter(number_instances >= ignore_number)
  
region_cap_include <- region_cap_data %>% 
  pull(region_cap)
  
final_data <- tidy_data %>% 
  filter(region_cap %in% region_cap_include)
  
ggplot(
  data = final_data, 
  mapping = aes(
    x = active_share, 
    y = tracking_error, 
    colour = cap_size)
  ) +
  geom_point(size = 0.4, alpha = 0.5) + 
  geom_smooth(method = "lm", formula = y ~ 0 + x, se = FALSE) +
  facet_wrap(
    ~ region, 
    scales = "free", 
    nrow = 4, 
    ncol = 5
    ) + 
  labs(
    colour = "Cap Size",
    title = "\n Comparing Tracking Error (y-axis) against Active Share (x-axis) in different regions (colours)",
    y = "", 
    x = ""
    ) + 
  theme(
    strip.text = element_text(size = 5),
    axis.text.x = element_text(size = 5),
    axis.text.y = element_text(size = 5), 
    plot.title = element_text(size = 10),
    legend.title = element_text(size = 8), 
    legend.text = element_text(size = 5)
    )
```

## Coefficients

Encouragingly, I find a positive relationship between tracking error and active share. I now calculate the specific coefficients involved in the robust best-fit lines shown above.

```{r te_as3, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE}
r_squared_cutoff <- 0.5
  
regression <- final_data %>% 
  split(.$region_cap) %>% 
  map(~ lm(TE_vs_AS ~ 0 + one_vs_sqrt_n, data = .))
  
region_cap_names <- final_data %>% 
  split(.$region_cap) %>% 
  map(0) %>% 
  names(.)
  
beta <- regression %>% 
  map(tidy) %>% 
  map("estimate") %>%
  as_vector(.)
  
r_squared <- regression %>% 
  map(summary) %>% 
  map_dbl("r.squared")
  
results <- cbind(region_cap_names, beta, r_squared) %>% 
  as_data_frame(.) %>% 
  left_join(region_cap_data, by = c("region_cap_names" = "region_cap")) %>% 
  mutate(
    beta = as.numeric(beta),
    r_squared = as.numeric(r_squared),
    fair_model = r_squared > r_squared_cutoff,
    av_idio_risk = beta / sqrt(2 * pi))
  
results_fair <- results %>% 
  filter(fair_model == TRUE) %>% 
  select(-beta, -fair_model) %>% 
  arrange(av_idio_risk)
  
datatable(
    data = results_fair,
    rownames = FALSE,
    options = list(
      dom = 'tip', 
      order = list(3, 'asc'),
      pageLength = 14)
    ) %>% 
    formatRound(
      columns = 4, 
      digits = 1) %>% 
    formatPercentage(
      columns = 2, 
      digits = 1)
```

## Conclusion

I sought to test whether Sapra's way of imputing tracking error from active share could work in practice. And the evidence seems positive. 

Specifically, the estimates of `av_idio_risk` (\(\bar{\sigma _{e}}\)) generated above seem broadly in line with what I would have previously expected. For context, consider their distribution across all mandates seems reasonable:

```{r te_as4, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE}
summary(results_fair$av_idio_risk)
```

Moreover, the edge cases also make sense:

  * The minimum value of `r round(results_fair$av_idio_risk[1], 2)` corresponds with the `r results_fair$region_cap_names[1]` mandate
  
  * The maximum value of `r round(results_fair$av_idio_risk[nrow(results_fair)], 2)` corresponds with the `r results_fair$region_cap_names[nrow(results_fair)]` mandate
  
Upon further scrutiny, Stephen and I find that each mandate can be bucketed alongside similar mandates and parameterized accordingly. And it is this parameterization that is codified into SAM.

***

For completeness and reproducibility, I now show the calculations used in this analysis.

## Calibration {.appendix}

```{r te_as2, eval=FALSE, echo=TRUE}
```

</br>

## Coefficients {.appendix}

```{r te_as3, eval=FALSE, echo=TRUE}
```

</br>

## Conclusion {.appendix}

```{r te_as4, eval=FALSE, echo=TRUE}
```

</br>

## System settings {.appendix}

```{r, eval=TRUE, echo=FALSE}
sessionInfo()
```
